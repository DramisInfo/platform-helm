name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    name: Helm Lint
    # Skip if commit message contains [skip ci] or [ci skip]
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Lint Helm chart
        run: helm lint platform-core

      - name: Test Helm template generation
        run: helm template platform-core platform-core

  test-combinations:
    runs-on: ubuntu-latest
    name: Test Chart Combinations
    needs: lint
    strategy:
      fail-fast: false
      matrix:
        test-scenario:
          - name: "minimal"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                nats:
                  enabled: true
          - name: "monitoring-stack"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                prometheus:
                  enabled: true
                grafana:
                  enabled: true
                loki:
                  enabled: true
                nats:
                  enabled: true
          - name: "security-stack"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                clusterIssuer:
                  letsencrypt:
                    enabled: true
                externalSecretOperator:
                  enabled: true
                nats:
                  enabled: true
          - name: "infrastructure-stack"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                crossplane:
                  enabled: true
                terraformOperator:
                  enabled: true
                atlas:
                  enabled: true
                nats:
                  enabled: true
          - name: "nats-gateway"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                nats:
                  enabled: true
                  gateway:
                    enabled: true
                    name: "test-cluster"
                    port: 7222
          - name: "full-stack"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                clusterIssuer:
                  letsencrypt:
                    enabled: true
                crossplane:
                  enabled: true
                atlas:
                  enabled: true
                terraformOperator:
                  enabled: true
                externalSecretOperator:
                  enabled: true
                prometheus:
                  enabled: true
                grafana:
                  enabled: true
                loki:
                  enabled: true
                nats:
                  enabled: true
                  gateway:
                    enabled: true
                    name: "test-cluster"
                    port: 7222
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Create values file
        run: |
          cat > test-values.yaml << 'EOF'
          ${{ matrix.test-scenario.values }}
          EOF

      - name: Test Helm template with ${{ matrix.test-scenario.name }} configuration
        run: |
          echo "Testing ${{ matrix.test-scenario.name }} configuration..."
          helm template platform-core platform-core -f test-values.yaml

      - name: Test Helm lint with ${{ matrix.test-scenario.name }} configuration
        run: |
          helm lint platform-core -f test-values.yaml

  package:
    runs-on: ubuntu-latest
    name: Package Chart
    needs: [lint, test-combinations, integration-test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Package Helm chart
        run: |
          helm package platform-core
          ls -la *.tgz

      - name: Upload chart package
        uses: actions/upload-artifact@v4
        with:
          name: helm-chart-package
          path: "*.tgz"
          retention-days: 30

  integration-test:
    runs-on: ubuntu-latest
    name: Integration Test with K8s
    needs: lint
    strategy:
      fail-fast: false
      matrix:
        test-scenario:
          - name: "minimal"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                nats:
                  enabled: true
          - name: "monitoring-stack"
            values: |
              global:
                clusterName: "test"
              bootstrap:
                prometheus:
                  enabled: true
                grafana:
                  enabled: true
                loki:
                  enabled: true
                nats:
                  enabled: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Create k8s Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: test-cluster
          wait: 60s

      - name: Install cert-manager
        run: |
          echo "Installing cert-manager..."
          kubectl create namespace cert-manager
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          helm install cert-manager jetstack/cert-manager \
            --namespace cert-manager \
            --set installCRDs=true \
            --wait \
            --timeout=5m

      - name: Install ArgoCD
        run: |
          echo "Installing ArgoCD..."
          kubectl create namespace argocd
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          
          # Create minimal ArgoCD values for testing
          cat > argocd-values.yaml << 'EOF'
          global:
            logging:
              level: warn
          configs:
            params:
              server.insecure: true
          server:
            extraArgs:
              - --insecure
          controller:
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 512Mi
          repoServer:
            resources:
              requests:
                cpu: 50m
                memory: 64Mi
              limits:
                cpu: 200m
                memory: 256Mi
          applicationSet:
            enabled: false
          notifications:
            enabled: false
          EOF
          
          helm install argocd argo/argo-cd \
            --namespace argocd \
            --values argocd-values.yaml \
            --wait \
            --timeout=10m

      - name: Wait for ArgoCD to be ready
        run: |
          echo "Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=Ready pods -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=Ready pods -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s
          kubectl wait --for=condition=Ready pods -l app.kubernetes.io/name=argocd-repo-server -n argocd --timeout=300s

      - name: Create values file
        run: |
          cat > test-values.yaml << 'EOF'
          ${{ matrix.test-scenario.values }}
          EOF

      - name: Test Helm template with validation on ${{ matrix.test-scenario.name }}
        run: |
          echo "Testing ${{ matrix.test-scenario.name }} configuration with K8s validation..."
          helm template platform-core platform-core -f test-values.yaml --validate

      - name: Dry run installation with ${{ matrix.test-scenario.name }} configuration
        run: |
          helm install --dry-run --debug platform-core-test platform-core -f test-values.yaml

      - name: Test actual installation with ArgoCD
        run: |
          echo "Testing actual installation with ${{ matrix.test-scenario.name }} configuration..."
          
          # Use the test scenario values but ensure we don't enable components that require external repos
          cat > installation-test-values.yaml << 'EOF'
          global:
            clusterName: "test"
          bootstrap:
            clusterIssuer:
              letsencrypt:
                enabled: true
            nats:
              enabled: true
            # Disable components that require external repositories or complex setup
            prometheus:
              enabled: false
            grafana:
              enabled: false
            loki:
              enabled: false
            crossplane:
              enabled: false
            terraformOperator:
              enabled: false
            atlas:
              enabled: false
            externalSecretOperator:
              enabled: false
          EOF
          
          # Install the chart
          helm install platform-core-test platform-core -f installation-test-values.yaml --wait --timeout=10m
          
          # Verify ArgoCD applications were created
          echo "Checking ArgoCD applications..."
          kubectl get applications -n argocd
          
          # Wait a bit for ArgoCD to process the applications
          sleep 30
          
          # Check application status
          kubectl get applications -n argocd -o wide
          
          # Verify some basic resources
          echo "Checking created resources..."
          kubectl get all -A
          
          # Clean up
          helm uninstall platform-core-test --wait

  release:
    runs-on: ubuntu-latest
    name: Automatic Version Bump and Release
    needs: [lint, test-combinations, integration-test, package]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump_version.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine version bump type
        id: bump_type
        run: |
          # Get the latest commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Determine bump type based on conventional commits
          if echo "$COMMIT_MSG" | grep -qE "^(feat|feature)(\(.+\))?!:|^BREAKING CHANGE:|breaking change"; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
            echo "Detected MAJOR version bump (breaking change)"
          elif echo "$COMMIT_MSG" | grep -qE "^feat(\(.+\))?:|^feature(\(.+\))?:"; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            echo "Detected MINOR version bump (new feature)"
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
            echo "Detected PATCH version bump (bug fix/other)"
          fi

      - name: Bump version in Chart.yaml
        id: bump_version
        env:
          BUMP_TYPE: ${{ steps.bump_type.outputs.bump_type }}
        run: |
          CHART_FILE="platform-core/Chart.yaml"
          CURRENT_VERSION=$(grep '^version:' $CHART_FILE | awk '{print $2}')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse version components
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # Increment version based on bump type
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          
          # Update Chart.yaml
          sed -i "s/^version: .*/version: $NEW_VERSION/" $CHART_FILE
          
          # Output for next steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Commit version bump
        env:
          NEW_VERSION: ${{ steps.bump_version.outputs.new_version }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add platform-core/Chart.yaml
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git push origin main

      - name: Create and push git tag
        env:
          NEW_VERSION: ${{ steps.bump_version.outputs.new_version }}
        run: |
          git tag -a "v$NEW_VERSION" -m "Release version $NEW_VERSION"
          git push origin "v$NEW_VERSION"

  update-platform-tools:
    runs-on: ubuntu-latest
    name: Update platform-tools
    needs: release
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout platform-tools repository
        uses: actions/checkout@v4
        with:
          repository: DramisInfo/platform-tools
          path: platform-tools
          token: ${{ secrets.GH_TOKEN }}

      - name: Update platform-core.yaml with new version
        env:
          NEW_VERSION: ${{ needs.release.outputs.version }}
        run: |
          sed -i "s/targetRevision: \".*\"/targetRevision: \"v$NEW_VERSION\"/" platform-tools/overlays/dev/patches/platform-core.yaml

      - name: Commit and push changes
        env:
          NEW_VERSION: ${{ needs.release.outputs.version }}
        run: |
          cd platform-tools
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add overlays/dev/patches/platform-core.yaml
          git commit -m "Update platform-core to version v$NEW_VERSION"
          git push origin main
